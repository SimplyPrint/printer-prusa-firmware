diff --git a/src/connect/connect.cpp b/src/connect/connect.cpp
index 11f458c1000216b402a39bc7534708111cf36e18..84e603266ce018e80361d3ee3138341072bd9223 100644
--- a/src/connect/connect.cpp
+++ b/src/connect/connect.cpp
@@ -44,7 +44,60 @@ LOG_COMPONENT_DEF(connect, LOG_SEVERITY_INFO);
 
 namespace connect_client {
 
+std::atomic<bool> is_print_network{false};
+
 namespace {
+    class SimplyPrintRequest final : public http::Request {
+    private:
+        HeaderOut headers[6];
+        const std::string &data;
+        size_t offset = 0; // Add offset to track progress through data
+
+
+    public:
+        SimplyPrintRequest(const std::string &data, const char* token, Printer * printer)
+            : headers {
+                { "Content-Type", "text/plain", nullopt },
+                { "Fingerprint", printer->printer_info().fingerprint, Printer::PrinterInfo::FINGERPRINT_HDR_SIZE },
+                { "Token", token, nullopt },
+                user_agent_printer,
+                user_agent_version,
+                { nullptr, nullptr, nullopt }
+            },
+            data(data) {}
+
+        // Implement required methods
+        virtual const char *url() const override {
+            return "/p/simplyprint";
+        }
+
+        virtual Method method() const override {
+            return Method::Post;
+        }
+
+        virtual const HeaderOut *extra_headers() const override {
+            return headers;
+        }
+
+        virtual ContentType content_type() const override {
+            return ContentType::TextPlain;
+        }
+
+        virtual const char *connection() const override {
+            return "keep-alive";
+        }
+
+        virtual std::variant<unsigned int, http::Error> write_body_chunk(char *buffer, size_t size) override {
+            const size_t max_chunk_size = 512 * 1024; // 512 KB, or adjust as needed
+            size_t chunk_size = std::min({size, max_chunk_size, data.size() - offset});
+            if (chunk_size == 0) {
+                return std::variant<unsigned int, http::Error>(static_cast<unsigned int>(0)); // No more data to send
+            }
+            std::memcpy(buffer, data.data() + offset, chunk_size);
+            offset += chunk_size;
+            return static_cast<unsigned int>(chunk_size);
+        }
+    };
 
     // Send a ping if there's no activity from us during this time (15_000 ms = 15s)
     constexpr uint32_t ping_inactivity = 15000;
@@ -249,13 +302,19 @@ Connect::ServerResp Connect::handle_server_resp(http::Response resp, CommandId c
     // whole request-response pair a successful one. That's OK, because on the
     // lower-level it is - we consumed all the data and are allowed to reuse
     // the connection and all that.
+    Command command;
     switch (resp.content_type) {
     case ContentType::TextGcode: {
         const string_view body(reinterpret_cast<const char *>(recv_buffer), size);
         return Command::gcode_command(command_id, body, move(*buff));
     }
     case ContentType::ApplicationJson:
-        return Command::parse_json_command(command_id, reinterpret_cast<char *>(recv_buffer), size, move(*buff));
+        command = Command::parse_json_command(command_id, reinterpret_cast<char *>(recv_buffer), size, move(*buff));
+        if (std::holds_alternative<StartPrint>(command.command_data)) {
+            is_print_network = true;
+        }
+        return command;
+
     default:;
         // If it's unknown content type, then it's unknown command because we
         // have no idea what to do about it / how to even parse it.
@@ -467,6 +526,9 @@ CommResult Connect::receive_command(CachedFactory &conn_factory) {
             switch (type) {
             case Type::Json: {
                 auto command = Command::parse_json_command(command_id, reinterpret_cast<char *>(buffer + HDR_LEN), read - HDR_LEN, move(*buff));
+                if (std::holds_alternative<StartPrint>(command.command_data)) {
+                    is_print_network = true;
+                }
                 planner().command(command);
                 break;
             }
@@ -621,6 +683,34 @@ CommResult Connect::prepare_connection(CachedFactory &conn_factory, const Printe
     return monostate {};
 }
 
+int Connect::send_simplyprint(const std::string &data) {
+    log_debug(connect, "Sending simple print data: %s", data.c_str());
+
+    // Create the SimplePrintRequest
+    CachedFactory conn_factory;
+    auto [config, cfg_changed] = printer.config();
+    SimplyPrintRequest request(data, config.token, &printer);
+    conn_factory.refresh(config);
+
+    // Prepare the HTTP client and send the request
+    HttpClient http(conn_factory);
+    auto result = http.send(request);
+
+    // Handle the response
+    if (holds_alternative<http::Error>(result)) {
+        log_error(connect, "Failed to send simple print data");
+        return -1; // Return a custom error code (e.g., -1 for failure)
+    } else {
+        // Extract the response
+        auto response = get<http::Response>(result);
+
+        // Log the success and return the HTTP status code
+        log_debug(connect, "Simple print data sent successfully with status code: %d", response.status);
+
+        return response.status; // Return the server's HTTP status code
+    }
+}
+
 CommResult Connect::send_command(CachedFactory &conn_factory, const Printer::Config &config, Action &&action, optional<CommandId> background_command_id) {
     log_debug(connect, "Sending to connect");
     BasicRequest request(printer, config, action, background_command_id);
